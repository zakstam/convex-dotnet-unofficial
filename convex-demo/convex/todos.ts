/**
 * Convex functions for todos table
 * 
 * This file was automatically generated by BackendGenerator.
 * Do not modify this file directly.
 */

import { mutation, query } from "./_generated/server";
import { v } from "convex/values";
import { Doc, Id } from "./_generated/dataModel";


// Helper Functions
// ================

/**
 * Converts a Convex document to client format for todos
 */
function cleanTodo(doc: any) {
  const cleaned = { ...doc };
  cleaned.id = doc._id.toString();
  delete cleaned._id;
  if (cleaned.dueDate === null || cleaned.dueDate === undefined) {
    delete cleaned.dueDate;
  }
  return cleaned;
}

/**
 * Creates a new todo document
 *
 * @param title string
 * @param description string
 * @param isCompleted boolean
 * @param priority TodoPriority
 * @param dueDate number
 * @param tags string[]
 * @param category string
 */
export const create = mutation({
  args: {
    title: v.string(),
    description: v.string(),
    isCompleted: v.boolean(),
    priority: v.union(v.literal("Low"), v.literal("Normal"), v.literal("High"), v.literal("Urgent")),
    dueDate: v.optional(v.number()),
    tags: v.array(v.string()),
    category: v.string(),
  },
  handler: async (ctx, args) => {
    const now = Date.now();
    const id = await ctx.db.insert("todos", {
      ...args,
      createdAt: now,
      updatedAt: now,
    });

    const created = await ctx.db.get(id);
    return created ? cleanTodo(created) : null;
  },
});

/**
 * Gets a todo document by ID
 *
 * @param id string
 */
export const get = query({
  args: {
    id: v.string(),
  },
  handler: async (ctx, args) => {
    const doc = await ctx.db.get(args.id as Id<"todos">);
    return doc ? cleanTodo(doc) : null;
  },
});

/**
 * Lists all todos documents
 */
export const list = query({
  args: {},
  handler: async (ctx, args) => {
    const docs = await ctx.db.query("todos").collect();
    return docs.map(cleanTodo);
  },
});

/**
 * Lists todos documents with pagination support
 *
 * @param paginationOpts any
 * @param limit number
 */
export const listPaginated = query({
  args: {
    paginationOpts: v.optional(v.any()),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const limit = args.limit ?? 10;

    const query = ctx.db.query("todos");

    const results = await query
      .order("desc")
      .paginate(args.paginationOpts ?? { numItems: limit });

    return {
      page: results.page.map(cleanTodo),
      isDone: results.isDone,
      continueCursor: results.continueCursor
    };
  },
});

/**
 * Returns the total count of todos documents
 */
export const count = query({
  args: {},
  handler: async (ctx, args) => {
    const docs = await ctx.db.query("todos").collect();
    return docs.length;
  },
});

/**
 * Checks if a todo document exists
 *
 * @param id string
 */
export const exists = query({
  args: {
    id: v.string(),
  },
  handler: async (ctx, args) => {
    const doc = await ctx.db.get(args.id as Id<"todos">);
    return doc !== null;
  },
});

/**
 * Updates a todo document
 *
 * @param id string
 * @param title string
 * @param description string
 * @param isCompleted boolean
 * @param priority TodoPriority
 * @param dueDate number
 * @param tags string[]
 * @param category string
 */
export const update = mutation({
  args: {
    id: v.string(),
    title: v.optional(v.string()),
    description: v.optional(v.string()),
    isCompleted: v.optional(v.boolean()),
    priority: v.optional(v.union(v.literal("Low"), v.literal("Normal"), v.literal("High"), v.literal("Urgent"))),
    dueDate: v.optional(v.number()),
    tags: v.optional(v.array(v.string())),
    category: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const existing = await ctx.db.get(args.id as Id<"todos">);
    if (!existing) {
      throw new Error(`Document with id ${args.id} not found`);
    }

    const updates: any = {};
    updates.updatedAt = Date.now();

    // Copy provided updates
    for (const [key, value] of Object.entries(args)) {
      if (key !== 'id' && value !== undefined) {
        updates[key] = value;
      }
    }

    await ctx.db.patch(args.id as Id<"todos">, updates);
    const updated = await ctx.db.get(args.id as Id<"todos">);
    return updated ? cleanTodo(updated) : null;
  },
});

/**
 * Deletes multiple todos documents
 *
 * @param ids string
 */
export const deleteMany = mutation({
  args: {
    ids: v.array(v.string()),
  },
  handler: async (ctx, args) => {
    let deletedCount = 0;

    for (const id of args.ids) {
      try {
        await ctx.db.delete(id as Id<"todos">);
        deletedCount++;
      } catch (error) {
        // Continue deleting other documents even if one fails
        console.error(`Failed to delete document ${id}:`, error);
      }
    }

    return { deletedCount, totalRequested: args.ids.length };
  },
});

/**
 * Deletes a todo document
 *
 * @param id string
 */
export const delete_ = mutation({
  args: {
    id: v.string(),
  },
  handler: async (ctx, args) => {
    const existing = await ctx.db.get(args.id as Id<"todos">);
    if (!existing) {
      throw new Error(`Document with id ${args.id} not found`);
    }

    await ctx.db.delete(args.id as Id<"todos">);
    return { success: true };
  },
});

/**
 * Searches todos by title
 *
 * @param searchText string
 */
export const searchByTitle = query({
  args: {
    searchText: v.string(),
  },
  handler: async (ctx, args) => {
    const results = await ctx.db
      .query("todos")
      .withSearchIndex("title", (q) => q.search("title", args.searchText))
      .collect();
    return results.map(cleanTodo);
  },
});

/**
 * Searches todos by description
 *
 * @param searchText string
 */
export const searchByDescription = query({
  args: {
    searchText: v.string(),
  },
  handler: async (ctx, args) => {
    const results = await ctx.db
      .query("todos")
      .withSearchIndex("description", (q) => q.search("description", args.searchText))
      .collect();
    return results.map(cleanTodo);
  },
});
