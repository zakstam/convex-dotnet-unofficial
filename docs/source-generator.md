# Source Generator

The Convex .NET SDK includes a source generator that creates type-safe C# constants from your Convex backend's TypeScript API definition.

## Overview

The `Convex.SourceGenerator` source generator reads your Convex backend's `api.d.ts` file (generated by Convex) and creates C# constants for function names. This provides:

- ✅ **Compile-time type safety** - Typos caught at build time
- ✅ **IntelliSense support** - Autocomplete for all function names
- ✅ **Refactoring safety** - Rename support across codebase
- ✅ **Zero runtime cost** - Constants are compile-time only

## How It Works

1. **Convex generates `api.d.ts`** when you run `npx convex dev`
2. **Source generator reads `api.d.ts`** during C# build
3. **C# constants are generated** automatically
4. **Use constants instead of strings** for function names

## Setup

### Step 1: Ensure Convex Generates API Definition

Make sure your Convex backend is set up and generates `api.d.ts`:

```bash
cd your-backend-directory
npx convex dev
```

This creates `convex/_generated/api.d.ts` automatically.

### Step 2: Point Generator to API Definition

In your C# project file, add the `api.d.ts` as an additional file:

```xml
<ItemGroup>
  <AdditionalFiles Include="../backend/convex/_generated/api.d.ts" />
</ItemGroup>
```

**Note:** Adjust the path to match your project structure.

### Step 3: Build Your Project

```bash
dotnet build
```

The generator runs automatically and creates constants in:
`obj/Debug/generated/Convex.SourceGenerator/ConvexFunctions.g.cs`

## Usage

### Before (Unsafe)

```csharp
// ❌ Magic string - typos = runtime errors
var todos = await client.Query<List<Todo>>("functions/list").ExecuteAsync();
await client.Mutate<Todo>("functions/createTodo").WithArgs(new { text = "..." }).ExecuteAsync();
```

### After (Type-Safe)

```csharp
using Convex.Generated;

// ✅ IntelliSense + compile-time validation
var todos = await client.Query<List<Todo>>(ConvexFunctions.Queries.List).ExecuteAsync();
await client.Mutate<Todo>(ConvexFunctions.Mutations.CreateTodo)
    .WithArgs(new { text = "..." })
    .ExecuteAsync();
```

## Generated Code Structure

The generator creates constants organized by function type:

```csharp
namespace Convex.Generated
{
    public static class ConvexFunctions
    {
        public static class Queries
        {
            /// <summary>Query: functions/list</summary>
            public const string List = "functions/list";

            /// <summary>Query: functions/getMessages</summary>
            public const string GetMessages = "functions/getMessages";
        }

        public static class Mutations
        {
            /// <summary>Mutation: functions/createTodo</summary>
            public const string CreateTodo = "functions/createTodo";

            /// <summary>Mutation: functions/sendMessage</summary>
            public const string SendMessage = "functions/sendMessage";
        }

        public static class Actions
        {
            /// <summary>Action: functions/sendEmail</summary>
            public const string SendEmail = "functions/sendEmail";
        }
    }
}
```

## Function Type Inference

The generator infers function types from naming patterns:

- **Queries**: Functions starting with `get`, `list`, or containing `search`
- **Mutations**: Functions starting with `send`, `create`, `update`, `delete`, `edit`, `toggle`, or `set`
- **Actions**: Everything else

**Important:** Function names match file paths. `convex/functions/getMessages.ts` becomes `"functions/getMessages"` in the constant.

If a function is categorized incorrectly, you can still use it - the constant value is correct regardless of the category.

## Analyzer Integration

The `Convex.Client.Analyzer` package includes analyzer **CVX004** that warns when you use raw strings instead of generated constants:

```csharp
// Warning: CVX004 - Use 'ConvexFunctions.Queries.GetMessages' instead of string literal
var messages = await client.Query<List<Message>>("functions/getMessages").ExecuteAsync();
```

Use Quick Actions (`Ctrl+.`) to automatically replace the string with the constant.

## Troubleshooting

### Constants Not Generating

1. **Verify `api.d.ts` path** - Check that the path in `<AdditionalFiles>` is correct
2. **Check file exists** - Ensure `api.d.ts` exists at the specified path
3. **Rebuild project** - Run `dotnet clean && dotnet build`
4. **Check build output** - Look for generator messages in build output

### Wrong Function Type

The generator infers types from naming patterns. If a function is categorized incorrectly:

- The constant value is still correct (it's just in the wrong category)
- You can use it regardless of category
- Consider renaming your function to match the pattern, or ignore the category

### Generator Not Running

1. **Check package reference** - Ensure `Convex.Client` package is referenced (generator is bundled)
2. **Verify .NET version** - Generator requires .NET SDK that supports source generators
3. **Check build logs** - Look for generator errors in build output

## Viewing Generated Code

To see the generated code for debugging:

```bash
dotnet build -p:EmitCompilerGeneratedFiles=true
```

Generated files will be in: `obj/Debug/generated/Convex.SourceGenerator/`

## Benefits

### Compile-Time Safety

- ✅ Typos caught at build time
- ✅ Breaking changes detected immediately
- ✅ Safe refactoring with rename support

### Developer Experience

- ✅ IntelliSense autocomplete for all function names
- ✅ Navigate to definition (jumps to constant)
- ✅ Find all references across your codebase

### Maintenance

- ✅ Single source of truth (TypeScript backend)
- ✅ Automatic sync with backend changes
- ✅ No manual updates needed

## See Also

- [Getting Started Guide](getting-started.md)
- [API Reference](api-reference.md)
- [Troubleshooting Guide](troubleshooting.md)
