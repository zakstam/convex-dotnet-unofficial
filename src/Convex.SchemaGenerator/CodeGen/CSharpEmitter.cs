#nullable enable

using System.Collections.Generic;
using System.Linq;
using System.Text;
using Convex.SchemaGenerator.Models;

namespace Convex.SchemaGenerator.CodeGen;

/// <summary>
/// Generates C# class code from table definitions.
/// </summary>
public class CSharpEmitter
{
    private readonly string _namespace;
    private readonly List<(string TypeName, List<FieldDefinition> Fields)> _nestedTypes = new();

    public CSharpEmitter(string targetNamespace)
    {
        _namespace = targetNamespace;
    }

    /// <summary>
    /// Emits a complete C# file for a table definition.
    /// </summary>
    public string EmitTableClass(TableDefinition table)
    {
        _nestedTypes.Clear();

        var sb = new StringBuilder();

        // Header
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// This file is automatically generated from your Convex schema.");
        sb.AppendLine("// Do not modify this file directly - changes will be overwritten.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System.Text.Json.Serialization;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine();
        sb.AppendLine($"namespace {_namespace}");
        sb.AppendLine("{");

        // Main table class
        EmitClass(sb, table.PascalName, table.Name, table.Fields, isTable: true, indent: 1);

        // Emit any nested types that were collected
        // Use index-based loop since EmitClass may add more nested types during iteration
        for (var i = 0; i < _nestedTypes.Count; i++)
        {
            var (typeName, fields) = _nestedTypes[i];
            sb.AppendLine();
            EmitClass(sb, typeName, null, fields, isTable: false, indent: 1);
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    private void EmitClass(
        StringBuilder sb,
        string className,
        string? tableName,
        List<FieldDefinition> fields,
        bool isTable,
        int indent)
    {
        var indentStr = new string(' ', indent * 4);

        // XML documentation
        if (isTable && tableName != null)
        {
            sb.AppendLine($"{indentStr}/// <summary>");
            sb.AppendLine($"{indentStr}/// Document type for the '{tableName}' table.");
            sb.AppendLine($"{indentStr}/// </summary>");
        }
        else
        {
            sb.AppendLine($"{indentStr}/// <summary>");
            sb.AppendLine($"{indentStr}/// Nested type for {className}.");
            sb.AppendLine($"{indentStr}/// </summary>");
        }

        sb.AppendLine($"{indentStr}public class {className}");
        sb.AppendLine($"{indentStr}{{");

        var propIndent = new string(' ', (indent + 1) * 4);

        // Add system fields for table types
        if (isTable)
        {
            // _id field
            sb.AppendLine($"{propIndent}/// <summary>The document ID.</summary>");
            sb.AppendLine($"{propIndent}[JsonPropertyName(\"_id\")]");
            sb.AppendLine($"{propIndent}public string Id {{ get; init; }} = default!;");
            sb.AppendLine();

            // _creationTime field
            sb.AppendLine($"{propIndent}/// <summary>The document creation time (Unix timestamp in milliseconds).</summary>");
            sb.AppendLine($"{propIndent}[JsonPropertyName(\"_creationTime\")]");
            sb.AppendLine($"{propIndent}public double CreationTime {{ get; init; }}");
            sb.AppendLine();
        }

        // Emit user-defined fields
        foreach (var field in fields)
        {
            EmitField(sb, field, className, propIndent);
        }

        sb.AppendLine($"{indentStr}}}");
    }

    private void EmitField(StringBuilder sb, FieldDefinition field, string parentTypeName, string indent)
    {
        // Determine the C# type
        var csharpType = TypeMapper.MapToCSharpType(
            field.Type,
            RegisterNestedType,
            parentTypeName,
            field.Name);

        // Handle optional types
        var isOptional = field.IsOptional || field.Type.Kind == ValidatorKind.Optional;

        // Get the actual type (unwrap optional if needed)
        var actualType = csharpType;
        if (field.Type.Kind == ValidatorKind.Optional && field.Type.InnerType != null)
        {
            actualType = TypeMapper.MapToCSharpType(
                field.Type.InnerType,
                RegisterNestedType,
                parentTypeName,
                field.Name);

            // Add nullable marker if needed
            if (!actualType.EndsWith("?"))
            {
                actualType = $"{actualType}?";
            }
        }
        else if (isOptional && !actualType.EndsWith("?"))
        {
            actualType = $"{actualType}?";
        }

        // Property name in PascalCase
        var propertyName = ToPascalCase(field.Name);

        // Emit the property
        sb.AppendLine($"{indent}[JsonPropertyName(\"{field.Name}\")]");

        // Determine the default value
        var defaultValue = GetDefaultValue(actualType, isOptional);

        sb.AppendLine($"{indent}public {actualType} {propertyName} {{ get; init; }}{defaultValue}");
        sb.AppendLine();
    }

    private string GetDefaultValue(string csharpType, bool isOptional)
    {
        // Reference types that are not nullable need = default!
        // Value types don't need a default
        // Nullable types don't need a default

        if (csharpType.EndsWith("?"))
        {
            return ""; // Nullable types don't need defaults
        }

        if (TypeMapper.IsValueType(csharpType))
        {
            return ""; // Value types have implicit defaults
        }

        // Reference types need default!
        return " = default!;";
    }

    private void RegisterNestedType(string typeName, List<FieldDefinition> fields)
    {
        // Avoid duplicates
        if (!_nestedTypes.Any(t => t.TypeName == typeName))
        {
            _nestedTypes.Add((typeName, fields));
        }
    }

    private static string ToPascalCase(string input)
    {
        if (string.IsNullOrEmpty(input))
        {
            return input;
        }

        // Handle snake_case and camelCase
        var result = new StringBuilder();
        var capitalizeNext = true;

        foreach (var c in input)
        {
            if (c == '_')
            {
                capitalizeNext = true;
            }
            else if (capitalizeNext)
            {
                result.Append(char.ToUpperInvariant(c));
                capitalizeNext = false;
            }
            else
            {
                result.Append(c);
            }
        }

        return result.ToString();
    }

    /// <summary>
    /// Emits the IsExternalInit polyfill for .NET Standard 2.1 compatibility.
    /// </summary>
    public static string EmitPolyfill()
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// This file provides the IsExternalInit type for .NET Standard 2.1 compatibility.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
        sb.AppendLine("#if NETSTANDARD2_0 || NETSTANDARD2_1 || NETCOREAPP2_0 || NETCOREAPP2_1 || NETCOREAPP2_2 || NETCOREAPP3_0 || NETCOREAPP3_1 || NET45 || NET451 || NET452 || NET46 || NET461 || NET462 || NET47 || NET471 || NET472 || NET48");
        sb.AppendLine("namespace System.Runtime.CompilerServices");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Reserved for use by the compiler for init-only property setters.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    internal static class IsExternalInit { }");
        sb.AppendLine("}");
        sb.AppendLine("#endif");

        return sb.ToString();
    }
}
