#nullable enable

using System.Collections.Generic;
using System.Linq;
using Convex.SourceGenerator.Core.Models;
using Convex.SourceGenerator.Core.TypeMapping;
using Convex.SourceGenerator.Core.Utilities;

namespace Convex.SourceGenerator.Modules;

/// <summary>
/// Generates type-safe argument classes for Convex functions.
/// </summary>
public class ArgumentsModule : IGenerationModule
{
    public string Name => "Arguments";

    public bool IsEnabled(GeneratorOptions options) => options.GenerateArgs;

    public IEnumerable<GeneratedFile> Generate(
        IReadOnlyList<TableDefinition> tables,
        IReadOnlyList<FunctionDefinition> functions,
        GeneratorOptions options)
    {
        var functionsWithArgs = functions.Where(f => f.Arguments.Count > 0).ToList();

        if (functionsWithArgs.Count == 0)
        {
            yield break;
        }

        // Count occurrences of each function name to detect conflicts
        var nameOccurrences = functionsWithArgs
            .GroupBy(f => f.Name)
            .ToDictionary(g => g.Key, g => g.Count());

        var sb = new SourceBuilder();
        var nestedTypes = new List<(string TypeName, List<FieldDefinition> Fields)>();

        sb.EmitFileHeader("This file is automatically generated from your Convex backend.");
        sb.EmitUsings("System.Text.Json.Serialization");
        sb.OpenNamespace(options.ArgsNamespace);

        foreach (var func in functionsWithArgs.OrderBy(f => f.ModulePath).ThenBy(f => f.Name))
        {
            // Use module prefix only if there are naming conflicts
            string className;
            if (nameOccurrences[func.Name] > 1)
            {
                // Add module prefix for disambiguation
                var moduleClassName = NamingConventions.ToModuleClassName(func.ModulePath);
                className = $"{moduleClassName}{func.Name}Args";
            }
            else
            {
                // Use simple class name: {FunctionName}Args (e.g., GetGameArgs)
                className = $"{func.Name}Args";
            }

            sb.EmitSummary($"Arguments for the {func.Name} {func.Type.ToLowerInvariant()}.");
            sb.OpenClass("public sealed", className, partial: true);

            foreach (var arg in func.Arguments)
            {
                EmitArgument(sb, arg, className, nestedTypes, options);
            }

            sb.CloseClass();
            sb.AppendLine();
        }

        // Emit nested types
        for (var i = 0; i < nestedTypes.Count; i++)
        {
            var (typeName, fields) = nestedTypes[i];
            EmitNestedClass(sb, typeName, fields, nestedTypes, options);
        }

        sb.CloseNamespace();

        yield return new GeneratedFile
        {
            FileName = "ConvexArgs.g.cs",
            Content = sb.ToString()
        };
    }

    private static void EmitArgument(
        SourceBuilder sb,
        ArgumentDefinition arg,
        string parentClassName,
        List<(string TypeName, List<FieldDefinition> Fields)> nestedTypes,
        GeneratorOptions options)
    {
        var pascalName = NamingConventions.ToPascalCase(arg.Name);

        // Use ValidatorType if available to properly handle nested types
        string csharpType;
        if (arg.ValidatorType != null)
        {
            var context = new TypeMappingContext
            {
                NestedTypeCallback = (typeName, fields) =>
                {
                    if (!nestedTypes.Any(t => t.TypeName == typeName))
                    {
                        nestedTypes.Add((typeName, fields));
                    }
                },
                IdTypeCallback = options.GenerateTypedIds
                    ? tableName => NamingConventions.Singularize(NamingConventions.ToPascalCase(tableName)) + "Id"
                    : null,
                ParentName = parentClassName,
                FieldName = arg.Name
            };
            csharpType = ConvexTypeMapper.MapToCSharpTypeWithContext(arg.ValidatorType, context);
        }
        else
        {
            csharpType = arg.CSharpType;
        }

        // Handle optional types
        if (arg.IsOptional && !csharpType.EndsWith("?"))
        {
            csharpType = $"{csharpType}?";
        }

        var requiredAttr = arg.IsOptional ? "" : "required ";

        sb.AppendLine($"[JsonPropertyName(\"{arg.Name}\")]");
        sb.AppendLine($"public {requiredAttr}{csharpType} {pascalName} {{ get; init; }}");
        sb.AppendLine();
    }

    private static void EmitNestedClass(
        SourceBuilder sb,
        string className,
        List<FieldDefinition> fields,
        List<(string TypeName, List<FieldDefinition> Fields)> nestedTypes,
        GeneratorOptions options)
    {
        sb.EmitSummary($"Nested type for {className}.");
        sb.OpenClass("public sealed", className, partial: true);

        foreach (var field in fields)
        {
            var context = new TypeMappingContext
            {
                NestedTypeCallback = (typeName, typeFields) =>
                {
                    if (!nestedTypes.Any(t => t.TypeName == typeName))
                    {
                        nestedTypes.Add((typeName, typeFields));
                    }
                },
                IdTypeCallback = options.GenerateTypedIds
                    ? tableName => NamingConventions.Singularize(NamingConventions.ToPascalCase(tableName)) + "Id"
                    : null,
                ParentName = className,
                FieldName = field.Name
            };

            var csharpType = ConvexTypeMapper.MapToCSharpTypeWithContext(field.Type, context);
            var pascalName = NamingConventions.ToPascalCase(field.Name);

            if (field.IsOptional && !csharpType.EndsWith("?"))
            {
                csharpType = $"{csharpType}?";
            }

            var requiredAttr = field.IsOptional ? "" : "required ";

            sb.AppendLine($"[JsonPropertyName(\"{field.Name}\")]");
            sb.AppendLine($"public {requiredAttr}{csharpType} {pascalName} {{ get; init; }}");
            sb.AppendLine();
        }

        sb.CloseClass();
        sb.AppendLine();
    }
}
