#nullable enable

using System.Collections.Generic;
using System.Linq;
using Convex.SourceGenerator.Core.Models;
using Convex.SourceGenerator.Core.Utilities;

namespace Convex.SourceGenerator.Modules;

/// <summary>
/// Generates type-safe argument classes for Convex functions.
/// </summary>
public class ArgumentsModule : IGenerationModule
{
    public string Name => "Arguments";

    public bool IsEnabled(GeneratorOptions options) => options.GenerateArgs;

    public IEnumerable<GeneratedFile> Generate(
        IReadOnlyList<TableDefinition> tables,
        IReadOnlyList<FunctionDefinition> functions,
        GeneratorOptions options)
    {
        var functionsWithArgs = functions.Where(f => f.Arguments.Count > 0).ToList();

        if (functionsWithArgs.Count == 0)
        {
            yield break;
        }

        // Count occurrences of each function name to detect conflicts
        var nameOccurrences = functionsWithArgs
            .GroupBy(f => f.Name)
            .ToDictionary(g => g.Key, g => g.Count());

        var sb = new SourceBuilder();

        sb.EmitFileHeader("This file is automatically generated from your Convex backend.");
        sb.EmitUsings("System.Text.Json.Serialization");
        sb.OpenNamespace(options.ArgsNamespace);

        foreach (var func in functionsWithArgs.OrderBy(f => f.ModulePath).ThenBy(f => f.Name))
        {
            // Use module prefix only if there are naming conflicts
            string className;
            if (nameOccurrences[func.Name] > 1)
            {
                // Add module prefix for disambiguation
                var moduleClassName = NamingConventions.ToModuleClassName(func.ModulePath);
                className = $"{moduleClassName}{func.Name}Args";
            }
            else
            {
                // Use simple class name: {FunctionName}Args (e.g., GetGameArgs)
                className = $"{func.Name}Args";
            }

            sb.EmitSummary($"Arguments for the {func.Name} {func.Type.ToLowerInvariant()}.");
            sb.OpenClass("public sealed", className);

            foreach (var arg in func.Arguments)
            {
                var pascalName = NamingConventions.ToPascalCase(arg.Name);
                var requiredAttr = arg.IsOptional ? "" : "required ";

                sb.AppendLine($"[JsonPropertyName(\"{arg.Name}\")]");
                sb.AppendLine($"public {requiredAttr}{arg.CSharpType} {pascalName} {{ get; init; }}");
                sb.AppendLine();
            }

            sb.CloseClass();
            sb.AppendLine();
        }

        sb.CloseNamespace();

        yield return new GeneratedFile
        {
            FileName = "ConvexArgs.g.cs",
            Content = sb.ToString()
        };
    }
}
