#nullable enable

using System.Collections.Generic;
using System.Linq;
using Convex.SourceGenerator.Core.Models;
using Convex.SourceGenerator.Core.Utilities;

namespace Convex.SourceGenerator.Modules;

/// <summary>
/// Generates function name constants from Convex function definitions.
/// </summary>
public class FunctionsModule : IGenerationModule
{
    public string Name => "Functions";

    public bool IsEnabled(GeneratorOptions options) => options.GenerateFunctions;

    public IEnumerable<GeneratedFile> Generate(
        IReadOnlyList<TableDefinition> tables,
        IReadOnlyList<FunctionDefinition> functions,
        GeneratorOptions options)
    {
        if (functions.Count == 0)
        {
            yield break;
        }

        var sb = new SourceBuilder();

        sb.EmitFileHeader("This file is automatically generated from your Convex backend.");
        sb.OpenNamespace(options.Namespace);

        sb.EmitSummary("Type-safe constants for Convex function names.");
        sb.OpenClass("public static", "ConvexFunctions");

        // Group by type first, then by module
        var grouped = functions.GroupBy(f => f.Type).OrderBy(g => g.Key);

        foreach (var typeGroup in grouped)
        {
            var className = NamingConventions.Pluralize(typeGroup.Key);

            sb.EmitSummary($"{typeGroup.Key} functions");
            sb.OpenClass("public static", className);

            var byModule = typeGroup.GroupBy(f => f.ModulePath).OrderBy(g => g.Key);

            foreach (var moduleGroup in byModule)
            {
                var moduleClassName = NamingConventions.ToModuleClassName(moduleGroup.Key);
                var funcsInModule = moduleGroup.ToList();

                // Single function with same name as module - emit directly
                if (funcsInModule.Count == 1 && funcsInModule[0].Name == moduleClassName)
                {
                    var func = funcsInModule[0];
                    sb.AppendLine($"/// <summary>{typeGroup.Key}: {func.Path}</summary>");
                    sb.AppendLine($"public const string {func.Name} = \"{func.Path}\";");
                    sb.AppendLine();
                }
                else
                {
                    // Multiple functions - use nested class
                    sb.AppendLine($"/// <summary>{typeGroup.Key} functions from {moduleGroup.Key}</summary>");
                    sb.OpenClass("public static", moduleClassName);

                    foreach (var func in funcsInModule.OrderBy(f => f.Name))
                    {
                        sb.AppendLine($"/// <summary>{typeGroup.Key}: {func.Path}</summary>");
                        sb.AppendLine($"public const string {func.Name} = \"{func.Path}\";");
                    }

                    sb.CloseClass();
                    sb.AppendLine();
                }
            }

            sb.CloseClass();
            sb.AppendLine();
        }

        sb.CloseClass();
        sb.CloseNamespace();

        yield return new GeneratedFile
        {
            FileName = "ConvexFunctions.g.cs",
            Content = sb.ToString()
        };
    }
}
