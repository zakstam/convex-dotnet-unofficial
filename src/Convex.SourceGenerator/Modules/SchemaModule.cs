#nullable enable

using System.Collections.Generic;
using System.Linq;
using Convex.SourceGenerator.Core.Models;
using Convex.SourceGenerator.Core.TypeMapping;
using Convex.SourceGenerator.Core.Utilities;

namespace Convex.SourceGenerator.Modules;

/// <summary>
/// Generates model classes from Convex schema definitions.
/// </summary>
public class SchemaModule : IGenerationModule
{
    public string Name => "Schema";

    public bool IsEnabled(GeneratorOptions options) => options.GenerateModels;

    public IEnumerable<GeneratedFile> Generate(
        IReadOnlyList<TableDefinition> tables,
        IReadOnlyList<FunctionDefinition> functions,
        GeneratorOptions options)
    {
        if (tables.Count == 0)
        {
            yield break;
        }

        // Generate polyfill
        yield return new GeneratedFile
        {
            FileName = "IsExternalInit.g.cs",
            Content = EmitPolyfill()
        };

        // Generate each table class
        foreach (var table in tables)
        {
            var source = EmitTableClass(table, options.ModelsNamespace);
            yield return new GeneratedFile
            {
                FileName = $"{table.PascalName}.g.cs",
                Content = source
            };
        }
    }

    private string EmitTableClass(TableDefinition table, string ns)
    {
        var nestedTypes = new List<(string TypeName, List<FieldDefinition> Fields)>();
        var sb = new SourceBuilder();

        sb.EmitFileHeader("This file is automatically generated from your Convex schema.");
        sb.EmitUsings("System.Text.Json.Serialization", "System.Collections.Generic");
        sb.OpenNamespace(ns);

        EmitClass(sb, table.PascalName, table.Name, table.Fields, isTable: true, nestedTypes);

        // Emit nested types
        for (var i = 0; i < nestedTypes.Count; i++)
        {
            var (typeName, fields) = nestedTypes[i];
            sb.AppendLine();
            EmitClass(sb, typeName, null, fields, isTable: false, nestedTypes);
        }

        sb.CloseNamespace();

        return sb.ToString();
    }

    private void EmitClass(
        SourceBuilder sb,
        string className,
        string? tableName,
        List<FieldDefinition> fields,
        bool isTable,
        List<(string TypeName, List<FieldDefinition> Fields)> nestedTypes)
    {
        if (isTable && tableName != null)
        {
            sb.EmitSummary($"Document type for the '{tableName}' table.");
        }
        else
        {
            sb.EmitSummary($"Nested type for {className}.");
        }

        sb.OpenClass("public", className);

        if (isTable)
        {
            sb.AppendLine("/// <summary>The document ID.</summary>");
            sb.AppendLine("[JsonPropertyName(\"_id\")]");
            sb.AppendLine("public string Id { get; init; } = default!;");
            sb.AppendLine();

            sb.AppendLine("/// <summary>The document creation time (Unix timestamp in milliseconds).</summary>");
            sb.AppendLine("[JsonPropertyName(\"_creationTime\")]");
            sb.AppendLine("public double CreationTime { get; init; }");
            sb.AppendLine();
        }

        foreach (var field in fields)
        {
            EmitField(sb, field, className, nestedTypes);
        }

        sb.CloseClass();
    }

    private void EmitField(
        SourceBuilder sb,
        FieldDefinition field,
        string parentTypeName,
        List<(string TypeName, List<FieldDefinition> Fields)> nestedTypes)
    {
        var csharpType = ConvexTypeMapper.MapToCSharpType(
            field.Type,
            (typeName, fields) =>
            {
                if (!nestedTypes.Any(t => t.TypeName == typeName))
                {
                    nestedTypes.Add((typeName, fields));
                }
            },
            parentTypeName,
            field.Name);

        var isOptional = field.IsOptional || field.Type.Kind == ValidatorKind.Optional;

        var actualType = csharpType;
        if (field.Type.Kind == ValidatorKind.Optional && field.Type.InnerType != null)
        {
            actualType = ConvexTypeMapper.MapToCSharpType(
                field.Type.InnerType,
                (typeName, fields) =>
                {
                    if (!nestedTypes.Any(t => t.TypeName == typeName))
                    {
                        nestedTypes.Add((typeName, fields));
                    }
                },
                parentTypeName,
                field.Name);

            if (!actualType.EndsWith("?"))
            {
                actualType = $"{actualType}?";
            }
        }
        else if (isOptional && !actualType.EndsWith("?"))
        {
            actualType = $"{actualType}?";
        }

        var propertyName = NamingConventions.ToPascalCase(field.Name);

        // Avoid property name collision with class name (C# error CS0542)
        if (propertyName == parentTypeName)
        {
            propertyName = $"{propertyName}Value";
        }

        var defaultValue = GetDefaultValue(actualType, isOptional);

        sb.AppendLine($"[JsonPropertyName(\"{field.Name}\")]");
        sb.AppendLine($"public {actualType} {propertyName} {{ get; init; }}{defaultValue}");
        sb.AppendLine();
    }

    private static string GetDefaultValue(string csharpType, bool isOptional)
    {
        if (csharpType.EndsWith("?"))
        {
            return "";
        }

        if (ConvexTypeMapper.IsValueType(csharpType))
        {
            return "";
        }

        return " = default!;";
    }

    private static string EmitPolyfill()
    {
        var sb = new SourceBuilder();

        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// This file provides the IsExternalInit type for .NET Standard 2.1 compatibility.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
        sb.AppendLine("#if NETSTANDARD2_0 || NETSTANDARD2_1 || NETCOREAPP2_0 || NETCOREAPP2_1 || NETCOREAPP2_2 || NETCOREAPP3_0 || NETCOREAPP3_1 || NET45 || NET451 || NET452 || NET46 || NET461 || NET462 || NET47 || NET471 || NET472 || NET48");
        sb.AppendLine("namespace System.Runtime.CompilerServices");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Reserved for use by the compiler for init-only property setters.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    internal static class IsExternalInit { }");
        sb.AppendLine("}");
        sb.AppendLine("#endif");

        return sb.ToString();
    }
}
