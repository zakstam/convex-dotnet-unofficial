#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using Convex.SourceGenerator.Core.Models;
using Convex.SourceGenerator.Core.TypeMapping;
using Convex.SourceGenerator.Core.Utilities;

namespace Convex.SourceGenerator.Modules;

/// <summary>
/// Generates model classes from Convex schema definitions.
/// </summary>
public class SchemaModule : IGenerationModule
{
    public string Name => "Schema";

    public bool IsEnabled(GeneratorOptions options) => options.GenerateModels;

    public IEnumerable<GeneratedFile> Generate(
        IReadOnlyList<TableDefinition> tables,
        IReadOnlyList<FunctionDefinition> functions,
        GeneratorOptions options)
    {
        if (tables.Count == 0)
        {
            yield break;
        }

        // Generate polyfill
        yield return new GeneratedFile
        {
            FileName = "IsExternalInit.g.cs",
            Content = EmitPolyfill()
        };

        // Generate each table class
        foreach (var table in tables)
        {
            var source = EmitTableClass(table, options);
            yield return new GeneratedFile
            {
                FileName = $"{table.PascalName}.g.cs",
                Content = source
            };
        }
    }

    private string EmitTableClass(TableDefinition table, GeneratorOptions options)
    {
        var nestedTypes = new List<(string TypeName, List<FieldDefinition> Fields)>();
        var enumNames = new HashSet<string>();
        var sb = new SourceBuilder();

        sb.EmitFileHeader("This file is automatically generated from your Convex schema.");
        sb.EmitUsings("System", "System.Text.Json.Serialization", "System.Collections.Generic", "Convex.Client.Infrastructure.Serialization");
        sb.OpenNamespace(options.ModelsNamespace);

        EmitClass(sb, table.PascalName, table.Name, table.Fields, isTable: true, nestedTypes, enumNames, options);

        // Emit nested types
        for (var i = 0; i < nestedTypes.Count; i++)
        {
            var (typeName, fields) = nestedTypes[i];
            sb.AppendLine();
            EmitClass(sb, typeName, null, fields, isTable: false, nestedTypes, enumNames, options);
        }

        sb.CloseNamespace();

        return sb.ToString();
    }

    private void EmitClass(
        SourceBuilder sb,
        string className,
        string? tableName,
        List<FieldDefinition> fields,
        bool isTable,
        List<(string TypeName, List<FieldDefinition> Fields)> nestedTypes,
        HashSet<string> enumNames,
        GeneratorOptions options)
    {
        if (isTable && tableName != null)
        {
            sb.EmitSummary($"Document type for the '{tableName}' table.");
        }
        else
        {
            sb.EmitSummary($"Nested type for {className}.");
        }

        sb.OpenClass("public", className, partial: true);

        if (isTable && tableName != null)
        {
            // Use typed ID if enabled, otherwise use string
            var idType = "string";
            if (options.GenerateTypedIds)
            {
                idType = className + "Id";
            }

            sb.AppendLine("/// <summary>The document ID.</summary>");
            sb.AppendLine("[JsonPropertyName(\"_id\")]");
            sb.AppendLine($"public {idType} Id {{ get; init; }} = default!;");
            sb.AppendLine();

            sb.AppendLine("/// <summary>The document creation time.</summary>");
            sb.AppendLine("[JsonPropertyName(\"_creationTime\")]");
            sb.AppendLine("[JsonConverter(typeof(ConvexDateTimeOffsetJsonConverter))]");
            sb.AppendLine("public global::System.DateTimeOffset CreationTime { get; init; }");
            sb.AppendLine();
        }

        foreach (var field in fields)
        {
            EmitField(sb, field, className, nestedTypes, enumNames, options);
        }

        sb.CloseClass();
    }

    private void EmitField(
        SourceBuilder sb,
        FieldDefinition field,
        string parentTypeName,
        List<(string TypeName, List<FieldDefinition> Fields)> nestedTypes,
        HashSet<string> enumNames,
        GeneratorOptions options)
    {
        var context = new TypeMappingContext
        {
            NestedTypeCallback = (typeName, fields) =>
            {
                if (!nestedTypes.Any(t => t.TypeName == typeName))
                {
                    nestedTypes.Add((typeName, fields));
                }
            },
            EnumCallback = enumDef =>
            {
                enumNames.Add(enumDef.Name);
            },
            IdTypeCallback = options.GenerateTypedIds
                ? tableName => NamingConventions.Singularize(NamingConventions.ToPascalCase(tableName)) + "Id"
                : null,
            ParentName = parentTypeName,
            FieldName = field.Name
        };

        var csharpType = ConvexTypeMapper.MapToCSharpTypeWithContext(field.Type, context);

        var isOptional = field.IsOptional || field.Type.Kind == ValidatorKind.Optional;

        var actualType = csharpType;
        if (field.Type.Kind == ValidatorKind.Optional && field.Type.InnerType != null)
        {
            actualType = ConvexTypeMapper.MapToCSharpTypeWithContext(field.Type.InnerType, context);

            if (!actualType.EndsWith("?"))
            {
                actualType = $"{actualType}?";
            }
        }
        else if (isOptional && !actualType.EndsWith("?"))
        {
            actualType = $"{actualType}?";
        }

        // Check if this is a timestamp field (number type with timestamp-like name)
        var isTimestamp = (actualType == "double" || actualType == "double?") &&
                          ConvexTypeMapper.IsTimestampField(field.Name);

        if (isTimestamp)
        {
            actualType = actualType == "double?" ? "global::System.DateTimeOffset?" : "global::System.DateTimeOffset";
        }

        var propertyName = NamingConventions.ToPascalCase(field.Name);

        // Avoid property name collision with class name (C# error CS0542)
        if (propertyName == parentTypeName)
        {
            propertyName = $"{propertyName}Value";
        }

        var defaultValue = GetDefaultValue(actualType, isOptional, enumNames);

        sb.AppendLine($"[JsonPropertyName(\"{field.Name}\")]");
        if (isTimestamp)
        {
            var converterType = actualType.EndsWith("?", StringComparison.Ordinal)
                ? "ConvexNullableDateTimeOffsetJsonConverter"
                : "ConvexDateTimeOffsetJsonConverter";
            sb.AppendLine($"[JsonConverter(typeof({converterType}))]");
        }
        sb.AppendLine($"public {actualType} {propertyName} {{ get; init; }}{defaultValue}");
        sb.AppendLine();
    }

    private static string GetDefaultValue(string csharpType, bool isOptional, HashSet<string> enumNames)
    {
        if (csharpType.EndsWith("?"))
        {
            return "";
        }

        if (ConvexTypeMapper.IsValueType(csharpType, enumNames))
        {
            return "";
        }

        return " = default!;";
    }

    private static string EmitPolyfill()
    {
        var sb = new SourceBuilder();

        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// This file provides the IsExternalInit type for .NET Standard 2.1 compatibility.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
        sb.AppendLine("#if NETSTANDARD2_0 || NETSTANDARD2_1 || NETCOREAPP2_0 || NETCOREAPP2_1 || NETCOREAPP2_2 || NETCOREAPP3_0 || NETCOREAPP3_1 || NET45 || NET451 || NET452 || NET46 || NET461 || NET462 || NET47 || NET471 || NET472 || NET48");
        sb.AppendLine("namespace System.Runtime.CompilerServices");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Reserved for use by the compiler for init-only property setters.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    internal static class IsExternalInit { }");
        sb.AppendLine("}");
        sb.AppendLine("#endif");

        return sb.ToString();
    }
}
