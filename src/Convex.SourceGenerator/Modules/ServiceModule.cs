#nullable enable

using System.Collections.Generic;
using System.Linq;
using Convex.SourceGenerator.Core.Models;
using Convex.SourceGenerator.Core.TypeMapping;
using Convex.SourceGenerator.Core.Utilities;

namespace Convex.SourceGenerator.Modules;

/// <summary>
/// Generates a unified service wrapper for Convex functions.
/// </summary>
public class ServiceModule : IGenerationModule
{
    public string Name => "Service";

    public bool IsEnabled(GeneratorOptions options) => options.GenerateServices;

    public IEnumerable<GeneratedFile> Generate(
        IReadOnlyList<TableDefinition> tables,
        IReadOnlyList<FunctionDefinition> functions,
        GeneratorOptions options)
    {
        if (functions.Count == 0)
        {
            yield break;
        }

        var sb = new SourceBuilder();

        sb.EmitFileHeader("This file is automatically generated from your Convex backend.");
        sb.EmitUsings(
            "System.Collections.Generic",
            "System.Threading",
            "System.Threading.Tasks",
            "Convex.Client");

        sb.OpenNamespace(options.ServicesNamespace);

        // Generate interface
        sb.EmitSummary("Unified service interface for all Convex functions.");
        sb.OpenInterface("public", "IConvexFunctionsService");

        foreach (var func in functions.OrderBy(f => f.ModulePath).ThenBy(f => f.Name))
        {
            var moduleClassName = NamingConventions.ToModuleClassName(func.ModulePath);
            var methodName = $"{moduleClassName}{func.Name}Async";
            var returnType = GetReturnType(func);
            var parameters = GetParameters(func, options);

            sb.EmitSummary($"Calls the {func.Path} {func.Type.ToLowerInvariant()}.");
            sb.AppendLine($"{returnType} {methodName}({parameters});");
            sb.AppendLine();
        }

        sb.CloseInterface();
        sb.AppendLine();

        // Generate implementation
        sb.EmitSummary("Unified service implementation for all Convex functions.");
        sb.AppendLine("public class ConvexFunctionsService : IConvexFunctionsService");
        sb.AppendLine("{");
        sb.Indent();

        sb.AppendLine("private readonly IConvexClient _client;");
        sb.AppendLine();
        sb.AppendLine("public ConvexFunctionsService(IConvexClient client)");
        sb.AppendLine("{");
        sb.Indent();
        sb.AppendLine("_client = client;");
        sb.Outdent();
        sb.AppendLine("}");
        sb.AppendLine();

        foreach (var func in functions.OrderBy(f => f.ModulePath).ThenBy(f => f.Name))
        {
            EmitServiceMethod(sb, func, options);
        }

        sb.CloseClass();
        sb.CloseNamespace();

        yield return new GeneratedFile
        {
            FileName = "ConvexService.g.cs",
            Content = sb.ToString()
        };
    }

    private void EmitServiceMethod(SourceBuilder sb, FunctionDefinition func, GeneratorOptions options)
    {
        var moduleClassName = NamingConventions.ToModuleClassName(func.ModulePath);
        var methodName = $"{moduleClassName}{func.Name}Async";
        var returnType = GetReturnType(func);
        var parameters = GetParameters(func, options);

        var clientMethod = func.Type switch
        {
            "Query" => "Query",
            "Mutation" => "Mutate",
            "Action" => "Action",
            _ => "Action"
        };

        var functionConstant = $"{options.Namespace}.ConvexFunctions.{NamingConventions.Pluralize(func.Type)}.{moduleClassName}";
        if (!func.IsDefaultExport)
        {
            functionConstant += $".{func.Name}";
        }

        sb.AppendLine($"public {returnType} {methodName}({parameters})");
        sb.AppendLine("{");
        sb.Indent();

        var genericType = GetGenericReturnType(func);

        if (func.Arguments.Count > 0)
        {
            sb.AppendLine($"return _client.{clientMethod}<{genericType}>({functionConstant})");
            sb.Indent();
            sb.AppendLine(".WithArgs(args)");
            sb.AppendLine(".ExecuteAsync(ct);");
            sb.Outdent();
        }
        else
        {
            sb.AppendLine($"return _client.{clientMethod}<{genericType}>({functionConstant})");
            sb.Indent();
            sb.AppendLine(".ExecuteAsync(ct);");
            sb.Outdent();
        }

        sb.Outdent();
        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static string GetReturnType(FunctionDefinition func)
    {
        if (func.ReturnType != null)
        {
            var csharpType = ConvexTypeMapper.MapToCSharpType(func.ReturnType);
            // Ensure return type is nullable for queries that might return null
            if (!csharpType.EndsWith("?") && !csharpType.StartsWith("System.Collections"))
            {
                csharpType += "?";
            }
            return $"Task<{csharpType}>";
        }

        return "Task<object?>";
    }

    private static string GetGenericReturnType(FunctionDefinition func)
    {
        if (func.ReturnType != null)
        {
            var csharpType = ConvexTypeMapper.MapToCSharpType(func.ReturnType);
            // Ensure return type is nullable for queries that might return null
            if (!csharpType.EndsWith("?") && !csharpType.StartsWith("System.Collections"))
            {
                csharpType += "?";
            }
            return csharpType;
        }

        return "object?";
    }

    private static string GetParameters(FunctionDefinition func, GeneratorOptions options)
    {
        var parts = new List<string>();

        if (func.Arguments.Count > 0)
        {
            var moduleClassName = NamingConventions.ToModuleClassName(func.ModulePath);
            var argsClassName = $"{options.ArgsNamespace}.{moduleClassName}{func.Name}Args";
            parts.Add($"{argsClassName} args");
        }

        parts.Add("CancellationToken ct = default");

        return string.Join(", ", parts);
    }
}
